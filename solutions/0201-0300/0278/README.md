**(№ 278) First Bad Version [easy]**

Дано число n. Оно означает сколько версий проекта какого-то продукта было сделано. Но одна из этих версий оказалась плохой. А так как все новые версии строятся на базе прошлой версии, то получается все последующие за первой плохой версией тоже плохие. Нам нужно найти первую плохую версию. В качестве помощи у нас есть функция isBadVersion(), она может отвечать только на вопрос плохая версия, которую мы ей показываем, или нет.

**Решение на JavaScript**

```javascript
var solution = function(isBadVersion) {
  return function(n) {
    let start = 1;
    let end = n;

    while (start < end) {
      let mid = start + Math.floor((end - start) / 2);
      if (!isBadVersion(mid)) {
        start = mid + 1;
      } else {
        end = mid;
      }
    }
    
    return start;
  };
};
```

**Объяснение решения**

Самый простой вариант здесь был это пойти от первой версии и дальше и каждую передавать в функцию isBadVersion(). И как только бы эта функция первый раз сказала, что версия плохая, значит мы бы нашли первую, все, ответ. Но версий может быть много, поэтому идти по очереди может быть не эффективно. Вместо линейного алгоритма будем использовать бинарный поиск. Его суть простая. В промежутке между первой версией и последней находим центральное значение. И спрашиваем у функции isBadVersion() это центральное значение плохая версия или нет. Если нет, тогда мы за начало следующего промежутка устанавливаем версию следующую после нашей центральной на данный момент. Это нужно, чтобы все версии, что стоят левее не проверять больше, они точно не плохие. Если функция скажет да, плохая версия, значит наоборот конец промежутка ставим на центр, потому что центр все равно проверяться не будет. Все правые версии плохие точно, их тоже рассматривать не стоит. Дальше в новом промежутку находим центр и повторяем. Рано или поздно сокращая диапазоны мы доберемся до первой плохой. 

**Ссылка на задачу:** https://leetcode.com/problems/first-bad-version/