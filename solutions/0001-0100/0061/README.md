**(№ 61) Rotate List [medium]**

Дан связный список и число k. Нужно сдвинуть элементы вправо k раз. При каждом сдвиге узел с конца списка перемещается в начало списка. В конце вернуть полученный связный список.

**Решение на JavaScript**

```javascript
var rotateRight = function(head, k) {
  if (!head) return head;

  let len = 1;
  let tail = head;
  let newHead = tail;

  while (tail.next) {
    tail = tail.next;
    len++;
  }
  tail.next = head;

  if (k %= len) {
    for (let i = 0; i < len - k; i++) tail = tail.next;
  }

  newHead = tail.next;
  tail.next = null;

  return newHead;
};
```

**Объяснение решения**

Можно сказать нам нужно вырезать некоторое количество узлов с конца с сохранением их порядка и вставить их в начало списка. Но количество узлов, которых нужно вырезать не обязательно равно `k`. Потому что мы можем сдвигать элементы столько раз, что они могут в исходное положение в какой-то момент встать и ничего перемещать не придется. Поэтому чтобы знать больше или меньше число `k` чем количество узлов нужно сначала узнать длину связного списка. Для этого мы заводим цикл и сохраняем количество пройденых узлов в переменную `len`. Чтобы это сделать мы заводим указатель `tail`, устанавливаем его на первый узел и проверяем есть ли у этой переменной следующий узел. Если есть продолжаем движение по списку, если нет, значит мы достигли последнего узла.
```
           tail
             |
[1, 2, 3, 4, 5] 
```
В последнем узле нет продолжения, но мы его устанавливаем ссылкой на первый узел связного списка. 
```
           tail
             |
[1, 2, 3, 4, 5, _ ] 
 ^              |
 |              |
 ----------------
```
То есть если теперь пойти по списку циклом и проверять каждый следующий узел на существование мы войдем в бесконечный цикл. Теперь нужно сделать так чтобы первым узлом стал узел, с которого мы начнем вырезать узлы. Для этого проверям больше или меньше число `k` чем количество узлов. Если меньше, то просто вычитаем из длины списка количество узлов и получим число узлов, который нужно пропустить с начала списка. Если больше, то сначала из число `k` вычесть столько раз длину списка, чтобы все полные круги вычесть и оставить только последний круг, в котором будет обычный сдвиг. И так как у нас указатель `tail` стоит на последнем элементы, мы перемещаем его на узел, предыдущий от того с которого начнем вырезать узлы.
```javascript
if (k %= len) {
  for (let i = 0; i < len - k; i++) tail = tail.next;
}
````
Допустим у нас число `k = 2`, а длина массива `5`. Это значит надо вырезать последний два элемента и поместить их в начало. Указатель `tail` будет стоять так:
```
      tail
       |
[1, 2, 3, 4, 5, _ ] 
 ^              |
 |              |
 ----------------
```
В конце мы вводим новый указатель newHead и устанавливаем его на узел следующий за узлом `tail`. Это и есть начало конечного связного списка.
```
      tail
       |
[1, 2, 3, 4, 5, _ ] 
 ^        |     |
 |        |     |
 ----------------
          |
          |
       newHead
```
И остается только избавится от зацикленности. Для этого у узла на который указывает `tail` нужно заменить следующий узел пустотой `null`. И в ответ вернуть `newHead`.
```
            tail
             |
[4, 5, _,  1, 2, 3]
 |     |   ^
 |     |   |
 |     ----
 |
newHead
```

**Ссылка на задачу:** https://leetcode.com/problems/rotate-list/