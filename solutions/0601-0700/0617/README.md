**(№ 617) Merge Two Binary Trees [easy]**

Даны два бинарных дерева **root1** и **root2**. Нужно их объединить в одно бинарное дерево и вернуть его. Нужно представить, что мы накладываем одно дерево на другое, корневой узел на корневой узел и все дочерние друг на друга. Если два узла перекрываются, то значения этих узлов суммируются как новое значение объединенного узла. Если не перекрываются, то узлом нового дерева будет тот, в котором есть значение.

**Решение на JavaScript**

```javascript
var mergeTrees = function(root1, root2) {
  if (!root1) return root2;
  if (!root2) return root1;

  root1.val += root2.val;
  root1.left = mergeTrees(root1.left, root2.left);
  root1.right = mergeTrees(root1.right, root2.right);

  return root1;
};
```

**Объяснение решения**

Используем рекурсивный метод.

```javascript
var mergeTrees = function(root1, root2) {
  // (*)
  if (!root1) return root2;
  if (!root2) return root1;

  // (1) Начинаем формировать новое дерево. Значения нового дерева будем
  // хранить в старом дереве **root1**. Когда только запускаем решение
  // сразу же суммируем корневые узлы обоих деревьев
  root1.val += root2.val;

  // (2) Затем для каждого дочернего узла нового дерева запускаем
  // функцию mergeTrees и передаем в нее дочерние элементы исходных деревьев.
  // В левую ветку нового дерева левые значения исходных деревьев.
  // В правую ветку нового дерева правые значения исходных деревьев.
  // Если хотя бы один узел исходного дерева нулевой, тогда возвращаем узел
  // из другого исходного дерева (*). Возвращаем узел и все последующие дочерние
  // значения этого узла. Для таких ситуаций нет смысла продолжал сравнивать узлы,
  // потому что очевидно такой набор узлов будет только у одного исходного
  // дерева и он полностью пойдет в новое дерево.
  // Если оба узла нулевые все равно возвращаем узел другого дерева, просто там
  // уже не важно из какого, что из другого, что из своего дерева
  // всегда вернется null.
  root1.left = mergeTrees(root1.left, root2.left);
  root1.right = mergeTrees(root1.right, root2.right);

  // (3) Когда будут пройдены все узлы, просуммированны или пустые ветки заменены
  // на значения в первом дереве root1, тогда просто возвращаем это дерево.
  return root1;
};
```

**Ссылка на задачу:** https://leetcode.com/problems/merge-two-binary-trees/