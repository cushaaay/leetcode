**(№ 953) Verifying an Alien Dictionary [easy]**

Даны массив слов `words`, написанных на инопланетном языке и строка `order` в которой записан алфавит инопланетного языке. Инопланетный язык содержит в себе все буквы английского языка, только в другом порядке. Нужно понять стоят ли слова в массиве в алфавитном порядке этого инопланетного языка, от меньшего к большему. Отсутствие буквы считается меньшим знаком, чем любая другая буква.

**Решение на JavaScript**

```javascript
var isAlienSorted = function(words, order) {
  const orderInd = {};
  for (let i = 0; i < order.length; i++) {
    orderInd[order[i]] = i;
  }

  for (let i = 0; i < words.length - 1; i++) {
    let w1 = words[i];
    let w2 = words[i + 1];

    for (let j = 0; j < w1.length; j++) {
      if (j === w2.length) return false;

      if (w1[j] !== w2[j]) {
        if (orderInd[w2[j]] < orderInd[w1[j]]) return false;
        break;
      }
    }
  }

  return true;
};
```

**Объяснение решения**

Будем проверять по два слова. Сначала первое и второе. Если они соответствуют всем правилам тогда переходим к второму и третьему. И так далее пока не переберем все слова. Если в процессе какое-то правила будет нарушено тогда заканчиваем проверку и возвращаем `false`. Если после всех проверок все хорошо, тогда возвращаем `true`. 

```javascript
var isAlienSorted = function(words, order) {
  // (1) Первращаем алфавит в карту символов, где в качестве ключа сам символ,
  // а в качестве значения его порядковый номер в алфавите. Это нужно чтобы
  // далее сравнивать буквы из разных слов в цифровом виде
  const orderInd = {};
  for (let i = 0; i < order.length; i++) {
    orderInd[order[i]] = i;
  }

  // (2) Начинаем идти по списку слов от первого, до предпоследнего. Не до
  // последнего, потому что мы будем проверять по два слова (3), так что это
  // обработка последнего случая, чтобы не было выхода за пределы массива
  for (let i = 0; i < words.length - 1; i++) {

    // (3) В переменные w1 и w2 записываем пару слов. Сначала первое и второе,
    // затем на следующей итерации цикла второе и третье и так далее
    let w1 = words[i];
    let w2 = words[i + 1];

    // (4) Далее начинаем перебирать буквы и запускаем цикл с количеством итераций
    // равным длине первого слова. Потому что хороший случай, когда в первом слове
    // символов либо меньше чем во втором слове, либо столько же, чтобы для каждого
    // символа из первого слова точно нашелся символ из второго слова. Если в первом
    // слове символов окажется меньше, чем во втором, то это первый признак, что
    // слова стоят в нужном порядке
    for (let j = 0; j < w1.length; j++) {

      // (5) Если окажется, что первое слово длиньше чем второе, то сразу возвращаем
      // ответ, что слова стоят не в алфавитном порядке
      if (j === w2.length) return false;

      // (6) Если символов в первом слове меньше или столько же, сколько во втором, то
      // начинаем сравнивать попарно первый символ первого слова с первым символом
      // второго слова, второй со вторым и так далее. Если символы совпадают, то ничего
      // не делаем
      if (w1[j] !== w2[j]) {

        // (7) Но если символы отличаются, нужно проверить порядковый номер в алфавите
        // символа из первого слова, меньше ли он, чем порядковый номер символа из второго
        // слова и если нет, тогда порядок нарушен, прерываем сравнение слов и возвращаем
        // ответ, что слова стоят не в алфавитном порядке
        if (orderInd[w2[j]] < orderInd[w1[j]]) return false;
        break;
      }
    }
  }

  // (8) Если после всех проверок ошибок не обнаружено, тогда слова стоят в алфавитном
  // порядке
  return true;
};
```

**Ссылка на задачу:** https://leetcode.com/problems/verifying-an-alien-dictionary/